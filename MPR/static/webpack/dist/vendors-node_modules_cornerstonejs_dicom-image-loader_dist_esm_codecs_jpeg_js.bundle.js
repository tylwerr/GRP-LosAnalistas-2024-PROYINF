"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkmpr"] = self["webpackChunkmpr"] || []).push([["vendors-node_modules_cornerstonejs_dicom-image-loader_dist_esm_codecs_jpeg_js"],{

/***/ "./node_modules/@cornerstonejs/dicom-image-loader/dist/esm/codecs/jpeg.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@cornerstonejs/dicom-image-loader/dist/esm/codecs/jpeg.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar ColorSpace = { Unkown: 0, Grayscale: 1, AdobeRGB: 2, RGB: 3, CYMK: 4 };\nvar dctZigZag = new Int32Array([\n    0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40,\n    48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29,\n    22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54,\n    47, 55, 62, 63,\n]);\nvar dctCos1 = 4017;\nvar dctSin1 = 799;\nvar dctCos3 = 3406;\nvar dctSin3 = 2276;\nvar dctCos6 = 1567;\nvar dctSin6 = 3784;\nvar dctSqrt2 = 5793;\nvar dctSqrt1d2 = 2896;\nfunction buildHuffmanTable(codeLengths, values) {\n    var k = 0, code = [], i, j, length = 16;\n    while (length > 0 && !codeLengths[length - 1])\n        length--;\n    code.push({ children: [], index: 0 });\n    var p = code[0], q;\n    for (i = 0; i < length; i++) {\n        for (j = 0; j < codeLengths[i]; j++) {\n            p = code.pop();\n            p.children[p.index] = values[k];\n            while (p.index > 0) {\n                p = code.pop();\n            }\n            p.index++;\n            code.push(p);\n            while (code.length <= i) {\n                code.push((q = { children: [], index: 0 }));\n                p.children[p.index] = q.children;\n                p = q;\n            }\n            k++;\n        }\n        if (i + 1 < length) {\n            code.push((q = { children: [], index: 0 }));\n            p.children[p.index] = q.children;\n            p = q;\n        }\n    }\n    return code[0].children;\n}\nfunction getBlockBufferOffset(component, row, col) {\n    return 64 * ((component.blocksPerLine + 1) * row + col);\n}\nfunction decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive) {\n    var precision = frame.precision;\n    var samplesPerLine = frame.samplesPerLine;\n    var scanLines = frame.scanLines;\n    var mcusPerLine = frame.mcusPerLine;\n    var progressive = frame.progressive;\n    var maxH = frame.maxH, maxV = frame.maxV;\n    var startOffset = offset, bitsData = 0, bitsCount = 0;\n    function readBit() {\n        if (bitsCount > 0) {\n            bitsCount--;\n            return (bitsData >> bitsCount) & 1;\n        }\n        bitsData = data[offset++];\n        if (bitsData == 0xff) {\n            var nextByte = data[offset++];\n            if (nextByte) {\n                throw 'unexpected marker: ' + ((bitsData << 8) | nextByte).toString(16);\n            }\n        }\n        bitsCount = 7;\n        return bitsData >>> 7;\n    }\n    function decodeHuffman(tree) {\n        var node = tree;\n        var bit;\n        while ((bit = readBit()) !== null) {\n            node = node[bit];\n            if (typeof node === 'number')\n                return node;\n            if (typeof node !== 'object')\n                throw 'invalid huffman sequence';\n        }\n        return null;\n    }\n    function receive(length) {\n        var n = 0;\n        while (length > 0) {\n            var bit = readBit();\n            if (bit === null)\n                return;\n            n = (n << 1) | bit;\n            length--;\n        }\n        return n;\n    }\n    function receiveAndExtend(length) {\n        var n = receive(length);\n        if (n >= 1 << (length - 1))\n            return n;\n        return n + (-1 << length) + 1;\n    }\n    function decodeBaseline(component, offset) {\n        var t = decodeHuffman(component.huffmanTableDC);\n        var diff = t === 0 ? 0 : receiveAndExtend(t);\n        component.blockData[offset] = component.pred += diff;\n        var k = 1;\n        while (k < 64) {\n            var rs = decodeHuffman(component.huffmanTableAC);\n            var s = rs & 15, r = rs >> 4;\n            if (s === 0) {\n                if (r < 15)\n                    break;\n                k += 16;\n                continue;\n            }\n            k += r;\n            var z = dctZigZag[k];\n            component.blockData[offset + z] = receiveAndExtend(s);\n            k++;\n        }\n    }\n    function decodeDCFirst(component, offset) {\n        var t = decodeHuffman(component.huffmanTableDC);\n        var diff = t === 0 ? 0 : receiveAndExtend(t) << successive;\n        component.blockData[offset] = component.pred += diff;\n    }\n    function decodeDCSuccessive(component, offset) {\n        component.blockData[offset] |= readBit() << successive;\n    }\n    var eobrun = 0;\n    function decodeACFirst(component, offset) {\n        if (eobrun > 0) {\n            eobrun--;\n            return;\n        }\n        var k = spectralStart, e = spectralEnd;\n        while (k <= e) {\n            var rs = decodeHuffman(component.huffmanTableAC);\n            var s = rs & 15, r = rs >> 4;\n            if (s === 0) {\n                if (r < 15) {\n                    eobrun = receive(r) + (1 << r) - 1;\n                    break;\n                }\n                k += 16;\n                continue;\n            }\n            k += r;\n            var z = dctZigZag[k];\n            component.blockData[offset + z] = receiveAndExtend(s) * (1 << successive);\n            k++;\n        }\n    }\n    var successiveACState = 0, successiveACNextValue;\n    function decodeACSuccessive(component, offset) {\n        var k = spectralStart, e = spectralEnd, r = 0;\n        while (k <= e) {\n            var z = dctZigZag[k];\n            switch (successiveACState) {\n                case 0:\n                    var rs = decodeHuffman(component.huffmanTableAC);\n                    var s = rs & 15;\n                    r = rs >> 4;\n                    if (s === 0) {\n                        if (r < 15) {\n                            eobrun = receive(r) + (1 << r);\n                            successiveACState = 4;\n                        }\n                        else {\n                            r = 16;\n                            successiveACState = 1;\n                        }\n                    }\n                    else {\n                        if (s !== 1)\n                            throw 'invalid ACn encoding';\n                        successiveACNextValue = receiveAndExtend(s);\n                        successiveACState = r ? 2 : 3;\n                    }\n                    continue;\n                case 1:\n                case 2:\n                    if (component.blockData[offset + z]) {\n                        component.blockData[offset + z] += readBit() << successive;\n                    }\n                    else {\n                        r--;\n                        if (r === 0)\n                            successiveACState = successiveACState == 2 ? 3 : 0;\n                    }\n                    break;\n                case 3:\n                    if (component.blockData[offset + z]) {\n                        component.blockData[offset + z] += readBit() << successive;\n                    }\n                    else {\n                        component.blockData[offset + z] =\n                            successiveACNextValue << successive;\n                        successiveACState = 0;\n                    }\n                    break;\n                case 4:\n                    if (component.blockData[offset + z]) {\n                        component.blockData[offset + z] += readBit() << successive;\n                    }\n                    break;\n            }\n            k++;\n        }\n        if (successiveACState === 4) {\n            eobrun--;\n            if (eobrun === 0)\n                successiveACState = 0;\n        }\n    }\n    function decodeMcu(component, decode, mcu, row, col) {\n        var mcuRow = (mcu / mcusPerLine) | 0;\n        var mcuCol = mcu % mcusPerLine;\n        var blockRow = mcuRow * component.v + row;\n        var blockCol = mcuCol * component.h + col;\n        var offset = getBlockBufferOffset(component, blockRow, blockCol);\n        decode(component, offset);\n    }\n    function decodeBlock(component, decode, mcu) {\n        var blockRow = (mcu / component.blocksPerLine) | 0;\n        var blockCol = mcu % component.blocksPerLine;\n        var offset = getBlockBufferOffset(component, blockRow, blockCol);\n        decode(component, offset);\n    }\n    var componentsLength = components.length;\n    var component, i, j, k, n;\n    var decodeFn;\n    if (progressive) {\n        if (spectralStart === 0)\n            decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;\n        else\n            decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;\n    }\n    else {\n        decodeFn = decodeBaseline;\n    }\n    var mcu = 0, marker;\n    var mcuExpected;\n    if (componentsLength == 1) {\n        mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;\n    }\n    else {\n        mcuExpected = mcusPerLine * frame.mcusPerColumn;\n    }\n    if (!resetInterval) {\n        resetInterval = mcuExpected;\n    }\n    var h, v;\n    while (mcu < mcuExpected) {\n        for (i = 0; i < componentsLength; i++) {\n            components[i].pred = 0;\n        }\n        eobrun = 0;\n        if (componentsLength == 1) {\n            component = components[0];\n            for (n = 0; n < resetInterval; n++) {\n                decodeBlock(component, decodeFn, mcu);\n                mcu++;\n            }\n        }\n        else {\n            for (n = 0; n < resetInterval; n++) {\n                for (i = 0; i < componentsLength; i++) {\n                    component = components[i];\n                    h = component.h;\n                    v = component.v;\n                    for (j = 0; j < v; j++) {\n                        for (k = 0; k < h; k++) {\n                            decodeMcu(component, decodeFn, mcu, j, k);\n                        }\n                    }\n                }\n                mcu++;\n            }\n        }\n        bitsCount = 0;\n        marker = (data[offset] << 8) | data[offset + 1];\n        if (marker <= 0xff00) {\n            throw 'marker was not found';\n        }\n        if (marker >= 0xffd0 && marker <= 0xffd7) {\n            offset += 2;\n        }\n        else {\n            break;\n        }\n    }\n    return offset - startOffset;\n}\nfunction quantizeAndInverse(component, blockBufferOffset, p) {\n    var qt = component.quantizationTable;\n    var v0, v1, v2, v3, v4, v5, v6, v7, t;\n    var i;\n    for (i = 0; i < 64; i++) {\n        p[i] = component.blockData[blockBufferOffset + i] * qt[i];\n    }\n    for (i = 0; i < 8; ++i) {\n        var row = 8 * i;\n        if (p[1 + row] === 0 &&\n            p[2 + row] === 0 &&\n            p[3 + row] === 0 &&\n            p[4 + row] === 0 &&\n            p[5 + row] === 0 &&\n            p[6 + row] === 0 &&\n            p[7 + row] === 0) {\n            t = (dctSqrt2 * p[0 + row] + 512) >> 10;\n            p[0 + row] = t;\n            p[1 + row] = t;\n            p[2 + row] = t;\n            p[3 + row] = t;\n            p[4 + row] = t;\n            p[5 + row] = t;\n            p[6 + row] = t;\n            p[7 + row] = t;\n            continue;\n        }\n        v0 = (dctSqrt2 * p[0 + row] + 128) >> 8;\n        v1 = (dctSqrt2 * p[4 + row] + 128) >> 8;\n        v2 = p[2 + row];\n        v3 = p[6 + row];\n        v4 = (dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128) >> 8;\n        v7 = (dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128) >> 8;\n        v5 = p[3 + row] << 4;\n        v6 = p[5 + row] << 4;\n        t = (v0 - v1 + 1) >> 1;\n        v0 = (v0 + v1 + 1) >> 1;\n        v1 = t;\n        t = (v2 * dctSin6 + v3 * dctCos6 + 128) >> 8;\n        v2 = (v2 * dctCos6 - v3 * dctSin6 + 128) >> 8;\n        v3 = t;\n        t = (v4 - v6 + 1) >> 1;\n        v4 = (v4 + v6 + 1) >> 1;\n        v6 = t;\n        t = (v7 + v5 + 1) >> 1;\n        v5 = (v7 - v5 + 1) >> 1;\n        v7 = t;\n        t = (v0 - v3 + 1) >> 1;\n        v0 = (v0 + v3 + 1) >> 1;\n        v3 = t;\n        t = (v1 - v2 + 1) >> 1;\n        v1 = (v1 + v2 + 1) >> 1;\n        v2 = t;\n        t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;\n        v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;\n        v7 = t;\n        t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;\n        v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;\n        v6 = t;\n        p[0 + row] = v0 + v7;\n        p[7 + row] = v0 - v7;\n        p[1 + row] = v1 + v6;\n        p[6 + row] = v1 - v6;\n        p[2 + row] = v2 + v5;\n        p[5 + row] = v2 - v5;\n        p[3 + row] = v3 + v4;\n        p[4 + row] = v3 - v4;\n    }\n    for (i = 0; i < 8; ++i) {\n        var col = i;\n        if (p[1 * 8 + col] === 0 &&\n            p[2 * 8 + col] === 0 &&\n            p[3 * 8 + col] === 0 &&\n            p[4 * 8 + col] === 0 &&\n            p[5 * 8 + col] === 0 &&\n            p[6 * 8 + col] === 0 &&\n            p[7 * 8 + col] === 0) {\n            t = (dctSqrt2 * p[i + 0] + 8192) >> 14;\n            p[0 * 8 + col] = t;\n            p[1 * 8 + col] = t;\n            p[2 * 8 + col] = t;\n            p[3 * 8 + col] = t;\n            p[4 * 8 + col] = t;\n            p[5 * 8 + col] = t;\n            p[6 * 8 + col] = t;\n            p[7 * 8 + col] = t;\n            continue;\n        }\n        v0 = (dctSqrt2 * p[0 * 8 + col] + 2048) >> 12;\n        v1 = (dctSqrt2 * p[4 * 8 + col] + 2048) >> 12;\n        v2 = p[2 * 8 + col];\n        v3 = p[6 * 8 + col];\n        v4 = (dctSqrt1d2 * (p[1 * 8 + col] - p[7 * 8 + col]) + 2048) >> 12;\n        v7 = (dctSqrt1d2 * (p[1 * 8 + col] + p[7 * 8 + col]) + 2048) >> 12;\n        v5 = p[3 * 8 + col];\n        v6 = p[5 * 8 + col];\n        t = (v0 - v1 + 1) >> 1;\n        v0 = (v0 + v1 + 1) >> 1;\n        v1 = t;\n        t = (v2 * dctSin6 + v3 * dctCos6 + 2048) >> 12;\n        v2 = (v2 * dctCos6 - v3 * dctSin6 + 2048) >> 12;\n        v3 = t;\n        t = (v4 - v6 + 1) >> 1;\n        v4 = (v4 + v6 + 1) >> 1;\n        v6 = t;\n        t = (v7 + v5 + 1) >> 1;\n        v5 = (v7 - v5 + 1) >> 1;\n        v7 = t;\n        t = (v0 - v3 + 1) >> 1;\n        v0 = (v0 + v3 + 1) >> 1;\n        v3 = t;\n        t = (v1 - v2 + 1) >> 1;\n        v1 = (v1 + v2 + 1) >> 1;\n        v2 = t;\n        t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;\n        v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;\n        v7 = t;\n        t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;\n        v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;\n        v6 = t;\n        p[0 * 8 + col] = v0 + v7;\n        p[7 * 8 + col] = v0 - v7;\n        p[1 * 8 + col] = v1 + v6;\n        p[6 * 8 + col] = v1 - v6;\n        p[2 * 8 + col] = v2 + v5;\n        p[5 * 8 + col] = v2 - v5;\n        p[3 * 8 + col] = v3 + v4;\n        p[4 * 8 + col] = v3 - v4;\n    }\n    for (i = 0; i < 64; ++i) {\n        var index = blockBufferOffset + i;\n        var q = p[i];\n        q =\n            q <= -2056 / component.bitConversion\n                ? 0\n                : q >= 2024 / component.bitConversion\n                    ? 255 / component.bitConversion\n                    : (q + 2056 / component.bitConversion) >> 4;\n        component.blockData[index] = q;\n    }\n}\nfunction buildComponentData(frame, component) {\n    var lines = [];\n    var blocksPerLine = component.blocksPerLine;\n    var blocksPerColumn = component.blocksPerColumn;\n    var samplesPerLine = blocksPerLine << 3;\n    var computationBuffer = new Int32Array(64);\n    var i, j, ll = 0;\n    for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {\n        for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {\n            var offset = getBlockBufferOffset(component, blockRow, blockCol);\n            quantizeAndInverse(component, offset, computationBuffer);\n        }\n    }\n    return component.blockData;\n}\nfunction clampToUint8(a) {\n    return a <= 0 ? 0 : a >= 255 ? 255 : a | 0;\n}\nclass JpegImage {\n    constructor() { }\n    load(path) {\n        var handleData = function (data) {\n            this.parse(data);\n            if (this.onload)\n                this.onload();\n        }.bind(this);\n        if (path.indexOf('data:') > -1) {\n            var offset = path.indexOf('base64,') + 7;\n            var data = atob(path.substring(offset));\n            var arr = new Uint8Array(data.length);\n            for (var i = data.length - 1; i >= 0; i--) {\n                arr[i] = data.charCodeAt(i);\n            }\n            handleData(data);\n        }\n        else {\n            var xhr = new XMLHttpRequest();\n            xhr.open('GET', path, true);\n            xhr.responseType = 'arraybuffer';\n            xhr.onload = function () {\n                var data = new Uint8Array(xhr.response);\n                handleData(data);\n            }.bind(this);\n            xhr.send(null);\n        }\n    }\n    parse(data) {\n        function readUint16() {\n            var value = (data[offset] << 8) | data[offset + 1];\n            offset += 2;\n            return value;\n        }\n        function readDataBlock() {\n            var length = readUint16();\n            var array = data.subarray(offset, offset + length - 2);\n            offset += array.length;\n            return array;\n        }\n        function prepareComponents(frame) {\n            var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / frame.maxH);\n            var mcusPerColumn = Math.ceil(frame.scanLines / 8 / frame.maxV);\n            for (var i = 0; i < frame.components.length; i++) {\n                component = frame.components[i];\n                var blocksPerLine = Math.ceil((Math.ceil(frame.samplesPerLine / 8) * component.h) / frame.maxH);\n                var blocksPerColumn = Math.ceil((Math.ceil(frame.scanLines / 8) * component.v) / frame.maxV);\n                var blocksPerLineForMcu = mcusPerLine * component.h;\n                var blocksPerColumnForMcu = mcusPerColumn * component.v;\n                var blocksBufferSize = 64 * blocksPerColumnForMcu * (blocksPerLineForMcu + 1);\n                component.blockData = new Int16Array(blocksBufferSize);\n                component.blocksPerLine = blocksPerLine;\n                component.blocksPerColumn = blocksPerColumn;\n            }\n            frame.mcusPerLine = mcusPerLine;\n            frame.mcusPerColumn = mcusPerColumn;\n        }\n        var offset = 0, length = data.length;\n        var jfif = null;\n        var adobe = null;\n        var pixels = null;\n        var frame, resetInterval;\n        var quantizationTables = [];\n        var huffmanTablesAC = [], huffmanTablesDC = [];\n        var fileMarker = readUint16();\n        if (fileMarker != 0xffd8) {\n            throw 'SOI not found';\n        }\n        fileMarker = readUint16();\n        while (fileMarker != 0xffd9) {\n            var i, j, l;\n            switch (fileMarker) {\n                case 0xffe0:\n                case 0xffe1:\n                case 0xffe2:\n                case 0xffe3:\n                case 0xffe4:\n                case 0xffe5:\n                case 0xffe6:\n                case 0xffe7:\n                case 0xffe8:\n                case 0xffe9:\n                case 0xffea:\n                case 0xffeb:\n                case 0xffec:\n                case 0xffed:\n                case 0xffee:\n                case 0xffef:\n                case 0xfffe:\n                    var appData = readDataBlock();\n                    if (fileMarker === 0xffe0) {\n                        if (appData[0] === 0x4a &&\n                            appData[1] === 0x46 &&\n                            appData[2] === 0x49 &&\n                            appData[3] === 0x46 &&\n                            appData[4] === 0) {\n                            jfif = {\n                                version: { major: appData[5], minor: appData[6] },\n                                densityUnits: appData[7],\n                                xDensity: (appData[8] << 8) | appData[9],\n                                yDensity: (appData[10] << 8) | appData[11],\n                                thumbWidth: appData[12],\n                                thumbHeight: appData[13],\n                                thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13]),\n                            };\n                        }\n                    }\n                    if (fileMarker === 0xffee) {\n                        if (appData[0] === 0x41 &&\n                            appData[1] === 0x64 &&\n                            appData[2] === 0x6f &&\n                            appData[3] === 0x62 &&\n                            appData[4] === 0x65 &&\n                            appData[5] === 0) {\n                            adobe = {\n                                version: appData[6],\n                                flags0: (appData[7] << 8) | appData[8],\n                                flags1: (appData[9] << 8) | appData[10],\n                                transformCode: appData[11],\n                            };\n                        }\n                    }\n                    break;\n                case 0xffdb:\n                    var quantizationTablesLength = readUint16();\n                    var quantizationTablesEnd = quantizationTablesLength + offset - 2;\n                    while (offset < quantizationTablesEnd) {\n                        var quantizationTableSpec = data[offset++];\n                        var tableData = new Int32Array(64);\n                        if (quantizationTableSpec >> 4 === 0) {\n                            for (j = 0; j < 64; j++) {\n                                var z = dctZigZag[j];\n                                tableData[z] = data[offset++];\n                            }\n                        }\n                        else if (quantizationTableSpec >> 4 === 1) {\n                            for (j = 0; j < 64; j++) {\n                                var zz = dctZigZag[j];\n                                tableData[zz] = readUint16();\n                            }\n                        }\n                        else\n                            throw 'DQT: invalid table spec';\n                        quantizationTables[quantizationTableSpec & 15] = tableData;\n                    }\n                    break;\n                case 0xffc0:\n                case 0xffc1:\n                case 0xffc2:\n                    if (frame) {\n                        throw 'Only single frame JPEGs supported';\n                    }\n                    readUint16();\n                    frame = {};\n                    frame.extended = fileMarker === 0xffc1;\n                    frame.progressive = fileMarker === 0xffc2;\n                    frame.precision = data[offset++];\n                    frame.scanLines = readUint16();\n                    frame.samplesPerLine = readUint16();\n                    frame.components = [];\n                    frame.componentIds = {};\n                    var componentsCount = data[offset++], componentId;\n                    var maxH = 0, maxV = 0;\n                    for (i = 0; i < componentsCount; i++) {\n                        componentId = data[offset];\n                        var h = data[offset + 1] >> 4;\n                        var v = data[offset + 1] & 15;\n                        if (maxH < h)\n                            maxH = h;\n                        if (maxV < v)\n                            maxV = v;\n                        var qId = data[offset + 2];\n                        l = frame.components.push({\n                            h: h,\n                            v: v,\n                            quantizationTable: quantizationTables[qId],\n                            quantizationTableId: qId,\n                            bitConversion: 255 / ((1 << frame.precision) - 1),\n                        });\n                        frame.componentIds[componentId] = l - 1;\n                        offset += 3;\n                    }\n                    frame.maxH = maxH;\n                    frame.maxV = maxV;\n                    prepareComponents(frame);\n                    break;\n                case 0xffc4:\n                    var huffmanLength = readUint16();\n                    for (i = 2; i < huffmanLength;) {\n                        var huffmanTableSpec = data[offset++];\n                        var codeLengths = new Uint8Array(16);\n                        var codeLengthSum = 0;\n                        for (j = 0; j < 16; j++, offset++)\n                            codeLengthSum += codeLengths[j] = data[offset];\n                        var huffmanValues = new Uint8Array(codeLengthSum);\n                        for (j = 0; j < codeLengthSum; j++, offset++)\n                            huffmanValues[j] = data[offset];\n                        i += 17 + codeLengthSum;\n                        (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);\n                    }\n                    break;\n                case 0xffdd:\n                    readUint16();\n                    resetInterval = readUint16();\n                    break;\n                case 0xffda:\n                    var scanLength = readUint16();\n                    var selectorsCount = data[offset++];\n                    var components = [], component;\n                    for (i = 0; i < selectorsCount; i++) {\n                        var componentIndex = frame.componentIds[data[offset++]];\n                        component = frame.components[componentIndex];\n                        var tableSpec = data[offset++];\n                        component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];\n                        component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];\n                        components.push(component);\n                    }\n                    var spectralStart = data[offset++];\n                    var spectralEnd = data[offset++];\n                    var successiveApproximation = data[offset++];\n                    var processed = decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, successiveApproximation & 15);\n                    offset += processed;\n                    break;\n                case 0xffff:\n                    if (data[offset] !== 0xff) {\n                        offset--;\n                    }\n                    break;\n                default:\n                    if (data[offset - 3] == 0xff &&\n                        data[offset - 2] >= 0xc0 &&\n                        data[offset - 2] <= 0xfe) {\n                        offset -= 3;\n                        break;\n                    }\n                    throw 'unknown JPEG marker ' + fileMarker.toString(16);\n            }\n            fileMarker = readUint16();\n        }\n        this.width = frame.samplesPerLine;\n        this.height = frame.scanLines;\n        this.jfif = jfif;\n        this.adobe = adobe;\n        this.components = [];\n        switch (frame.components.length) {\n            case 1:\n                this.colorspace = ColorSpace.Grayscale;\n                break;\n            case 3:\n                if (this.adobe)\n                    this.colorspace = ColorSpace.AdobeRGB;\n                else\n                    this.colorspace = ColorSpace.RGB;\n                break;\n            case 4:\n                this.colorspace = ColorSpace.CYMK;\n                break;\n            default:\n                this.colorspace = ColorSpace.Unknown;\n        }\n        for (var i = 0; i < frame.components.length; i++) {\n            var component = frame.components[i];\n            if (!component.quantizationTable &&\n                component.quantizationTableId !== null)\n                component.quantizationTable =\n                    quantizationTables[component.quantizationTableId];\n            this.components.push({\n                output: buildComponentData(frame, component),\n                scaleX: component.h / frame.maxH,\n                scaleY: component.v / frame.maxV,\n                blocksPerLine: component.blocksPerLine,\n                blocksPerColumn: component.blocksPerColumn,\n                bitConversion: component.bitConversion,\n            });\n        }\n    }\n    getData16(width, height) {\n        if (this.components.length !== 1)\n            throw 'Unsupported color mode';\n        var scaleX = this.width / width, scaleY = this.height / height;\n        var component, componentScaleX, componentScaleY;\n        var x, y, i;\n        var offset = 0;\n        var numComponents = this.components.length;\n        var dataLength = width * height * numComponents;\n        var data = new Uint16Array(dataLength);\n        var componentLine;\n        var lineData = new Uint16Array((this.components[0].blocksPerLine << 3) *\n            this.components[0].blocksPerColumn *\n            8);\n        for (i = 0; i < numComponents; i++) {\n            component = this.components[i];\n            var blocksPerLine = component.blocksPerLine;\n            var blocksPerColumn = component.blocksPerColumn;\n            var samplesPerLine = blocksPerLine << 3;\n            var j, k, ll = 0;\n            var lineOffset = 0;\n            for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {\n                var scanLine = blockRow << 3;\n                for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {\n                    var bufferOffset = getBlockBufferOffset(component, blockRow, blockCol);\n                    var offset = 0, sample = blockCol << 3;\n                    for (j = 0; j < 8; j++) {\n                        var lineOffset = (scanLine + j) * samplesPerLine;\n                        for (k = 0; k < 8; k++) {\n                            lineData[lineOffset + sample + k] =\n                                component.output[bufferOffset + offset++];\n                        }\n                    }\n                }\n            }\n            componentScaleX = component.scaleX * scaleX;\n            componentScaleY = component.scaleY * scaleY;\n            offset = i;\n            var cx, cy;\n            var index;\n            for (y = 0; y < height; y++) {\n                for (x = 0; x < width; x++) {\n                    cy = 0 | (y * componentScaleY);\n                    cx = 0 | (x * componentScaleX);\n                    index = cy * samplesPerLine + cx;\n                    data[offset] = lineData[index];\n                    offset += numComponents;\n                }\n            }\n        }\n        return data;\n    }\n    getData(width, height) {\n        var scaleX = this.width / width, scaleY = this.height / height;\n        var component, componentScaleX, componentScaleY;\n        var x, y, i;\n        var offset = 0;\n        var Y, Cb, Cr, K, C, M, Ye, R, G, B;\n        var colorTransform;\n        var numComponents = this.components.length;\n        var dataLength = width * height * numComponents;\n        var data = new Uint8Array(dataLength);\n        var componentLine;\n        var lineData = new Uint8Array((this.components[0].blocksPerLine << 3) *\n            this.components[0].blocksPerColumn *\n            8);\n        for (i = 0; i < numComponents; i++) {\n            component = this.components[i];\n            var blocksPerLine = component.blocksPerLine;\n            var blocksPerColumn = component.blocksPerColumn;\n            var samplesPerLine = blocksPerLine << 3;\n            var j, k, ll = 0;\n            var lineOffset = 0;\n            for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {\n                var scanLine = blockRow << 3;\n                for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {\n                    var bufferOffset = getBlockBufferOffset(component, blockRow, blockCol);\n                    var offset = 0, sample = blockCol << 3;\n                    for (j = 0; j < 8; j++) {\n                        var lineOffset = (scanLine + j) * samplesPerLine;\n                        for (k = 0; k < 8; k++) {\n                            lineData[lineOffset + sample + k] =\n                                component.output[bufferOffset + offset++] *\n                                    component.bitConversion;\n                        }\n                    }\n                }\n            }\n            componentScaleX = component.scaleX * scaleX;\n            componentScaleY = component.scaleY * scaleY;\n            offset = i;\n            var cx, cy;\n            var index;\n            for (y = 0; y < height; y++) {\n                for (x = 0; x < width; x++) {\n                    cy = 0 | (y * componentScaleY);\n                    cx = 0 | (x * componentScaleX);\n                    index = cy * samplesPerLine + cx;\n                    data[offset] = lineData[index];\n                    offset += numComponents;\n                }\n            }\n        }\n        switch (numComponents) {\n            case 1:\n            case 2:\n                break;\n            case 3:\n                colorTransform = true;\n                if (this.adobe && this.adobe.transformCode)\n                    colorTransform = true;\n                else if (typeof this.colorTransform !== 'undefined')\n                    colorTransform = !!this.colorTransform;\n                if (colorTransform) {\n                    for (i = 0; i < dataLength; i += numComponents) {\n                        Y = data[i];\n                        Cb = data[i + 1];\n                        Cr = data[i + 2];\n                        R = clampToUint8(Y - 179.456 + 1.402 * Cr);\n                        G = clampToUint8(Y + 135.459 - 0.344 * Cb - 0.714 * Cr);\n                        B = clampToUint8(Y - 226.816 + 1.772 * Cb);\n                        data[i] = R;\n                        data[i + 1] = G;\n                        data[i + 2] = B;\n                    }\n                }\n                break;\n            case 4:\n                if (!this.adobe)\n                    throw 'Unsupported color mode (4 components)';\n                colorTransform = false;\n                if (this.adobe && this.adobe.transformCode)\n                    colorTransform = true;\n                else if (typeof this.colorTransform !== 'undefined')\n                    colorTransform = !!this.colorTransform;\n                if (colorTransform) {\n                    for (i = 0; i < dataLength; i += numComponents) {\n                        Y = data[i];\n                        Cb = data[i + 1];\n                        Cr = data[i + 2];\n                        C = clampToUint8(434.456 - Y - 1.402 * Cr);\n                        M = clampToUint8(119.541 - Y + 0.344 * Cb + 0.714 * Cr);\n                        Y = clampToUint8(481.816 - Y - 1.772 * Cb);\n                        data[i] = C;\n                        data[i + 1] = M;\n                        data[i + 2] = Y;\n                    }\n                }\n                break;\n            default:\n                throw 'Unsupported color mode';\n        }\n        return data;\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (JpegImage);\n\n\n//# sourceURL=webpack://mpr/./node_modules/@cornerstonejs/dicom-image-loader/dist/esm/codecs/jpeg.js?");

/***/ })

}]);